#### 1、贪心算法

买股票，记录每天的价格，计算最大收益的买与抛的和，比如7，1，5，3，6，4，收益1，5和3，6，结果应该是7

```java
public int maxProfit (int[] prices) {
    //记录最大盈利
    int total = 0;
    for(int i = 1; i < prices.length; i++){
        //如果当前元素比之前元素大，就记录这个盈利
        if(prices[i] - prices[i-1] > 0){
            total += prices[i] - prices[i-1];
        }
    }
    return total;
}
```



#### 2、约瑟夫环

有个将军叫约瑟夫，与罗马帝国的作战中兵败，带着副官和39名士兵躲到一个山洞，但是约瑟夫和副官准备投降，39名士兵要求殉国，然后约瑟夫就提出大家围成一个圈，数到3的人就自杀，请问约瑟夫和副官站在哪两个位置能活下来？

```java
public static int[] josephCircle (int count,int num,int lastCount){
        //标记出局人数
        int outNum = 0;
   		//标记计数到哪一个人
        int index = 0;
    	//标记每一个人的状态
        boolean[] markStatus = new boolean[count];
     	//记录要返回的最后几个数字的数组
        int[] lastArr = new int[lastCount];
    	//最后几个数的索引标志位
        int lastIndex = 0;
        while(outNum != count){
            for(int i = 0; i < count; i++){
                if(markStatus[i])continue;
                index++;
                if(index == num){
                    System.out.println((i+1)+"号出局");
                    markStatus[i] = true;
                    index = 0;
                    outNum++;
                    if(outNum >= count - lastCount + 1){
                        lastArr[lastIndex++] = i + 1;
                    }
                }
            }
        }
        return lastArr;
    }
```



#### 3、剑指Offer系列

##### （1）二维数组查数

在一个二维数组中（每一个数组的长度相同）。每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的排序。请完成一个函数，输入二维数组和一个整数，判断数组中是否含有该数组。

数组示例：`{{1,3,5,8},{2,4,7,9},{6,10,11,13}}`

```java
public class Test {
    public static boolean find (int[][] arr,int val){
        int row = 0;
        int column = arr[0].length - 1;
        while(true){
            if(column < 0 || row > arr[0].length - 1){
                break;
            }
            if(val == arr[row][column]){
                return true;
            }else if(val > arr[row][column]){
                row++;
                continue;
            }else if(val < arr[row][column]){
                column--;
                continue;
            }
        }
    }
}
```

二维数组有序递增，查找代码：

```java
public static boolean find (int[][] arr,int val){
        int len = arr[0].length - 1;
        if(val < arr[0][0] || val > arr[arr.length-1][len]){
            return false;
        }
        int targetRow = 0;
    	//确定列的位置
        for(int i = 0; i < arr.length; i++){
            if(val > arr[targetRow][len]){
                targetRow++;
            }else if(val < arr[targetRow][len]){
                break;
            }else{
                return true;
            }
        }
        return binarySearch(arr[targetRow],val);
}

public static boolean binarySearch(int[] arr,int val){
        int right = arr.length - 1;
        int left = 0;
        if(val < arr[0] || val > arr[right]){
            return false;
        }
        int middle = 0;
        //这个判断很重要，如果是right!=left会漏掉一次比较
        while(right >= left){
            middle = (left + right) / 2;
            if(val > arr[middle]){
                left = middle + 1;
            }else if(val < arr[middle]){
                right = middle - 1;
            }else if(val == arr[middle]){
                return true;
            }
        }
        return false;
}
```



##### （2）倒序打印单向链表

```java
public class Test{
    public static ArrayList<Integer> printList (Node node){
        if(node == null){
            return new ArrayList<>();
        }
        if(node.next != null){
            ArrayList<Node> result = printList(node.next);
            result.add(node.val);
            return result;
        }else{
            ArrayList<Node> result = new ArrayList<>();
            result.add(node);
            return result;
        }
    }
}
class Node {
    int val;
    int Node next;
    public Node (int val){
        this.val = val;
    }
    public void setNext (Node node) {
        this.next = node;
    }
}
```



##### （3）重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，根据结果重建二叉树并返回（假设前序遍历和中序遍历的结果中都不含重复的数字）

前：1，2，4，7，3，5，6，8

中：4，7，2，1，5，3，8，6

根节点1，左4，7，2，右5，3，8，6

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        //根据前序遍历和中序遍历结果重构二叉树
        if(pre.length == 0 || in.length == 0){
            return null;
        }
        TreeNode node = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++){
            if(in[i] == pre[0]){
                //重构左子树
                int[] leftPre = new int[i];
                int[] leftInfix = new int[i];
                System.arraycopy(pre,1,leftPre,0,i);
                System.arraycopy(in,0,leftInfix,0,i);
                TreeNode left = reConstructBinaryTree(leftPre,leftInfix);
            
                //重构右子树
                int[] rightPre = new int[pre.length - i - 1];
                int[] rightInfix =  new int[pre.length - i - 1];
                System.arraycopy(pre,i+1,rightPre,0,pre.length - i - 1);
                System.arraycopy(in,i+1,rightInfix,0,pre.length - i - 1);
                TreeNode right = reConstructBinaryTree(rightPre,rightInfix);
            
                //挂载节点
                node.left = left;
                node.right = right;
                return node;
        }
    } 
    return node;
    }
}
class Node {
    int val;
    Node left;
    Node right;
    public Node (int val){
        this.val = val;
    }
}

```



##### （4）栈和队列

用两个栈来实现一个队列，完成push和pop操作，队列中元素为`int`类型

```java
public class Test {
    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();
    //1 2 3 4要先取出1
    public void push (int value){
        stack1.push(value);
    }
    
    public int pop () {
        if(stack1.size() == 0){
            System.out.println("queue is null.");
            return -1;
        }
        while(stack1.size() > 0){
            stack2.push(stack1.pop());
        }
        int result = stack2.pop();
        while(stack2.size() > 0){
            stack1.push(stack2.pop());
        }
        return result;
    }
}
```



##### （5）数组旋转

把一个数组开始的若干元素搬到数组的末尾，我们称之为数组旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3，4，5，1，2}为{1，2，3，4，5}的一个旋转，该数组的最小值为1。给出所有元素都大于0，若数组大小为0，返回0。

```java
public int rotateArray (int[] arr) {
    for(int i = 0; i < arr.length - 1; i++){
        //因为有序，如果出现前面比后面大就是旋转数组的最小值了
        if(arr[i] - arr[i+1] > 0){
            return arr[i+1];
        }
    }
    return 0;
}
```



##### （6）青蛙跳台阶

一直青蛙可以跳上1级台阶，也可以跳上2级，求该青蛙跳上n级台阶总共有多少种跳法？（先后次序不同算不同的结果）

思路：假设青蛙从最底下，跳到k-1有m种跳法，跳到k-2有n种跳法，那么青蛙从最底下跳到最上面是n+m种跳法

分析：

1级台阶：1种跳法

2级台阶：2种跳法

3级台阶：1 + 2 ，3种跳法

4级台阶：2 + 3，5种跳法

..............................

n级台阶：m + n种跳法（斐波那契数列）

```java
public static int jumpFloor (int target){
    if(target == 1)return 1;
    if(target == 2)return 2;
    return jumpFloor(target - 1) + jumpFloor(target - 2);
}
```



##### （7）变态跳台阶

f(n) = f(n-1) + f(n-2) + f(n-3) + ...... + f(1)

```java
//动态规划
public int abnormalJumpFloor (int target){
    if(target == 1)return 1;
    if(target == 2)return 2;
    int sum = 0;
    for(int i = 0; i < target - 1; i++){
         sum += JumpFloorII(target - i - 1);
    }
    //注意有直接跳上台阶的1次，不要遗漏
    return sum + 1;
}
```



##### （8）矩形覆盖问题

我们可以用2\*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2\*n的大矩形，总共有多少种方法？

```java
public int rectCover (int target){
    if(target < 1)return 0;
    if(target == 1)return 1;
    if(target == 2)return 2;
    return rectCover(target - 1) + rectCover(target - 2);
}
```



##### （9）求幂问题

给定一个double类型的浮点数base和int类型的整数exponent，求base的exponent次方

```java
public double exponentOfBase(double base,int exp){
    if(exp == 0)return 1;
    double result = 1.0;
    for(int i = 0; i < Math.abs(exp); i++){
        result *= base;
    }
    return exp > 0 ? result : 1d / result;
}
```



##### （10）链表相关

输入一个链表，输出该链表种到数第K个节点

```java
public class Test {
    public static ListNode printKthTotail (ListNode head,int k) {
        if(k <= 0)return null;
        ListNode temp;
        ListNode target = head;
        while(true){
            temp = target;
            for(int i = 0; i < k; i++){
                //如果执行过程中temp为空，表示k值过大
                if(temp == null)return null;
                temp = temp.next;
            }
            if(temp == null){
                return target;
            }
            target = target.next;
        }
    }
}

class ListNode {
    int val;
    int next;
    public ListNode (int val){
        this.val = val;
    }
}
```



输入一个链表，反转链表并将新的表头返回

1，2，3，4，5

执行过程：

一直递归到5节点，返回5节点

到4节点，5指针指向4

到3节点，4指针指向3，3的next指针清空

到2节点，3指针指向2，2的next指针清空

```java
public ListNode reverseList (ListNode head) {
    if(head == null)return null;
    //返回新的表头
    if(head.next = null)return head;
    //如果下一个节点的next指针为空，直接指向当前节点
    if(head.next.next == null){
        head.next.next = head;
    }else{
        //如果下一个节点的next指针不为空
        ListNode result = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return result;
    }
}
```



输入两个单调递增的链表，输出合成后的链表，合成后的链表依然单调

1，3，5，7，9

2，4，6，8，10

```java
public static ListNode merge (ListNode list1,ListNode list2) {
    if(list1 == null && list2 == null)return null;
    if(list1 == null)return list2;
    if(list2 == null)return list1;
    if(list1.val < list2.val){
        //函数本质是找最小值，然后挂载到当前节点后面
        list1.next = merge(list1.next,list2);
        return list1;
    }else{
        list2.next = merge(list1,list2.next);
        return list2;
    }
}
```



leetcode链表的整数相加

链表1：2，4，5

链表2：3，7，4

输出：5，1，0，1

```java
//leetcode链表的整数相加
    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        ListNode head = new ListNode(l1.val + l2.val);
        int index = 0;
        if(l1.val + l2.val >= 10){
            head.val = l1.val + l2.val - 10;
            index = 1;
        }
        //下一个节点的指针
        ListNode curNode = head;
        ListNode temp1 = l1.next;
        ListNode temp2 = l2.next;
        //穿节点
        while (temp1 != null || temp2 != null) {
            ListNode newNode = null;
            int sum = 0;
            if (temp1 == null) {
                sum = temp2.val + index;
            }
            if (temp2 == null) {
                sum = temp1.val + index;
            }
            if(temp1 != null && temp2 != null){
                sum = temp1.val + temp2.val + index;
            }
            if(sum >= 10){
                newNode = new ListNode(sum - 10);
                index = 1;
            }else{
                newNode = new ListNode(sum);
                index = 0;
            }
            if(temp1 != null) temp1 = temp1.next;
            if(temp2 != null) temp2 = temp2.next;
            curNode.next = newNode;
            curNode = curNode.next;
        }
        if(index == 1)curNode.next = new ListNode(index);
        return head;
    }

class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

    public void list () {
        System.out.println(this.val);
        ListNode temp = this.next;
        while(temp != null){
            System.out.println(temp.val);
            temp = temp.next;
        }
    }
}
```



##### （11）二叉树相关

输入两棵二叉树A、B，判断B不是A的子结构。（约定空树不是任意一个树的子结构）

```java
public boolean isSubtree (TreeNode node1,TreeNode node2) {
    if(node1 == null || node2 == null)return false;
    if(node1 == node2)return true;
    return isSame(node1,node2) || isSubtree(noded1.left,node2) || isSubtree(node1.right,node2);
}

public boolean isSame (TreeNode node1,TreeNode node2) {
    if(node2 == null)return true;
    if(node1 == null)return false;
    if(node1.val == node2.val){
        return isSame(node1.left,node2.left) && isSame(node1.right,node2.right);
    }else{
        return false;
    } 
}
```



操作给定的二叉树，将其变换为源二叉树的镜像

分析：就是节点的左右子树交换位置

> ```
> 二叉树的镜像定义：源二叉树 
>     	    8
>     	   /  \
>     	  6   10
>     	 / \  / \
>     	5  7 9 11
>     	镜像二叉树
>     	    8
>     	   /  \
>     	  10   6
>     	 / \  / \
>     	11 9 7  5
> ```

```java
public static void Mirror (TreeNode root){
    if(root == null)return;
    //递归
    Mirror(root.left);
    Mirror(root.right);
    //左右子树交换
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
}
```



##### （12）顺时针打印矩阵

> 1   2   3    4 
> 5   6   7    8
>
> 9  10  11  12
>
> 输出：1 2 3 4 8 12 11 10 9 5 6 7

分析功能：自动转向，移动后设置墙壁

```java
public ArrayList<Integer> printMatrix (int[][] matrix) {
    //记录存储了多少个数
    int num = 0;
    //记录行列
    int row = 0;
    int column = 0;
    //方向设计
    int[][] toward = {
        {0,1},//向右
        {1,0},//向下
        {0,-1},//向上
        {-1,0}//向左
    };
    int[] nowToward = toward[num % 4];
    ArrayList<Integer> result = new ArrayList<>();
    while(true){
        result.add(matrix[row][column]);//每次将当前值加到集合中
        matrix[row][column] = Integer.MAX_VALUE;
        if(result.size() >= matrix.length*matrix[0].length)break;
        while(true){
            //判断下一步是否会越界
        	int nextRow = row + nowToward[0];
        	int nextColumn = column + nowToward[1];
        	if(nextRow < 0 || nextColumn < 0 || nextRow >= matrix.length || nextColumn >= matrix[0].length || matrix[nextRow][nextColumn] == Integer.MAX_VALUE){
            	//通过num++改变方向
            	num++;
            	nowToward = toward[num % 4];
       		 }else{
            	break;
        	 }
        }
        //运动
        row += nowToward[0];
        column += nowToward[1];
    }
    return result;
}
```



##### （13）栈相关

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数

```java
public class Solution {
	//初始化数组大小128
    int[] arr = new int[128];
    //记录使用长度的指针
    int pointer = 0;
    int min = Integer.MAX_VALUE;

    public void push(int node) throws Exception {
        min = Math.min(min,node);
        //判断是否扩容
        if(pointer > arr.length - 1){
            if(pointer >= Integer.MAX_VALUE)throw new Exception("size is great than Integer.MAX_VALUE.");
            int growSize = (int)(arr.length*1.75);
            if(growSize > Integer.MAX_VALUE)growSize = Integer.MAX_VALUE;
            int[] newArr = new int[growSize];
            System.arraycopy(arr,0,newArr,0,arr.length);
            arr = newArr;
        }
        arr[pointer++] = node;
    }

    public void pop() {
        if(pointer == 0){
            System.out.println("current stack is empty.");
            return;
        }
        if(arr[pointer - 1] == min){
            min = Integer.MAX_VALUE;
            for(int i = 0; i < pointer - 1; i++){
              min = Math.min(min,arr[i]);
            }
        }
        pointer--;
    }

    public int top() {
        if(pointer == 0){
            System.out.println("stack is empty.");
            return -1;
        }
        return arr[pointer-1];
    }

    public int min() {
        return min;
    }
```



输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```java
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
      	int[] stack = new int[pushA.length];
        int stackPointer = 0;
        int pushPointer = 0;
        int popPointer = 0;
        while(true){
            if(stackPointer <= 0 || popA[popPointer] != stack[stackPointer-1]){
                if(pushPointer >= pushA.length)return false;
                stack[stackPointer]  = pushA[pushPointer];
                stackPointer++;
                pushPointer++;
            }
            if(popA[popPointer] == stack[stackPointer-1]){
                popPointer++;
                stackPointer--;
                if(popPointer >= popA.length){
                    return true;
                }
            }
        }
    }
}
```



##### （13）二叉树相关

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出yes，否则输出no。假设输入的数组的任意两个数字都不相同





##### （14）罗马数字转整数

leetcode算法题

```java
 //leetcode罗马数字转整数
    public static int romanToInt (String s){
        //先用字典来存储
        HashMap<String,Integer> map = new HashMap<>();
        map.put("I",1);
        map.put("V",5);
        map.put("X",10);
        map.put("L",50);
        map.put("C",100);
        map.put("D",500);
        map.put("M",1000);
        map.put("IV",4);
        map.put("IX",9);
        map.put("XL",40);
        map.put("XC",90);
        map.put("CD",400);
        map.put("CM",900);
        int sum = 0;
        for (int i = 0; i < s.length(); ) {
            boolean flag = false;
            if (i + 1 < s.length()) {
                String twoStr = s.substring(i, i + 2);
                if (map.containsKey(twoStr)) {
                    sum += (Integer) map.get(twoStr);
                    i += 2;
                    flag = true;
                }
            }

            if (flag == false) {
                String str = s.substring(i, i + 1);
                int num = (Integer) map.get(str);
                sum += num;
                i += 1;
            }
        }

        return sum;
    }
```



##### （15）开方问题

输入一个整数x，求x的1/2次幂

牛顿迭代公式推导：

> 1、F(x) = X ^ 2 - N，求F(x) = 0与X轴的交点
>
> 原理：找到X轴交点最靠近的整数，然后让它对应的Y值通过增量不断靠近0，获得X轴的近似值
>
> 分析：
>
> （1）切线方程：Y1 - Y0 =  k ( X1 - X0)
>
> （2）因为Y0= X0 ^ 2 - N，Y1 = 0，得到X1 = X0 - Y0 /  k
>
> （3） 求导公式：当X = X0时，k = 2 * X0 
>
> （4）X1 = X0 - （X0^2 - N）/  (2*X0) = X0 / 2 + N / (2 * X0)
>
> （5）迭代3次获取的近似值可以精确度达到10 ^ -10

```java
public class MySqrt {

    /*
    * （1）先找到左边最靠近的值
    * （2）利用牛顿迭代法3次可以得到误差较小的近似值
    * */
    public static double sqrt (int x) {
        if(x == 0 || x == 1) return 1.0d;
        int left = 1;
        int right = x / 2 + 1;
        int sqrt = 0;
        int mid = 0;
        while(left < right){
            mid = (left + right) / 2;
            sqrt = mid * mid;
            if(sqrt == x) {
                return mid;
            }
            if(sqrt > x){
                right = mid;
            }else{
                if(left == mid){
                    return newtonIterator(mid,x);
                }
                left = mid;
            }
        }
        return (double)mid;
    }

    /*
    * 牛顿迭代公式: Xn+1 = Xn*1/2 + value / (2*Xn)
    * */
    public static double newtonIterator (int mid,int x) {
        double temp = (double) mid;
        int count = 3;
        double res = 0;
        while(count >= 0) {
            res = temp*0.5 + x / (2*temp);
            temp = res;
            count--;
        }
        return res;
    }  
}
```



##### （16）摩尔斯密码

输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

摩尔斯字典：[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]

```java
public static int uniqueMorseRepresentations(String[] words) {
        String[] morseDic = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        HashSet result = new HashSet();
        for(int i = 0; i < words.length; i++){
            char[] chars = words[i].toCharArray();
            StringBuilder sb = new StringBuilder();
            for(char c : chars){
                sb.append(morseDic[c - 97]);
            }
            //利用HashSet去重
            result.add(sb.toString());
        }
        return result.size();
}
```



##### （17）缺失数字

George Boolean：乔治·布尔，将逻辑学与数学结合起来。（leetcode：268）

给定一个包含0，1，2，......，n的序列

找出0-n中没有出现在序列中的那个数

示例：[3, 0, 1]

输出：2

示例：[9, 6, 5, 7, 2, 3, 1, 0]

输出：8

```java
public class MissingNumber {
    //本质就是缺失的索引
    public static int findMissingNum (int[] nums){
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < nums.length; i++){
            set.add(nums[i]);
        }
        for(int i = 0; i <= nums.length; i++){
            if(!set.contains(i)){
                return i;
            }
        }
        return -1;
    }
    //根据索引
    //array:[0,1,2,4]
    //index: 0,1,2,3
    public static int findMissingNum2 (int[] nums){
        Arrays.sort(nums);
        for(int i = 0; i <= nums.length; i++){
            if(nums[i] != i){
                return i;;
            }
        }
        if(nums.length != nums[nums.length-1]){
            return nums.length;
        }
        return -1;
    }
    //异或方法
    //array:[4,3,0,1]  nums.length就是最大值
    //index: 0,1,2,3
    //result = (4^4^3^3^1^1^0^0) ^ 2 = 2 
    public static int findMissingNum2 (int[] nums){
        int result = nums.length;
        for(int i = 0; i < nums.length; i++){
            result = result ^ nums[i] ^ i;
        }
        return result;
    }
    //高斯求和
    public static int findMissingNum2 (int[] nums){
        int result = (1+nums.length)*nums.length / 2;
        int numSum = 0;
        for(int i = 0; i < nums.length; i++){
            numSum += nums[i];
        }
        return result - numSum;
    }
}
```



##### （18）杨辉三角

> ​                 1				11^0
>
> ​         	1         1       11^1
>
> ​         1      2       1			11^2
>
> ​     1     3         3      1        11^3
>
> 1       4       6        4       1 
>
> 特点：
>
> （1）n行组合的数字 11^(n -  1)
>
> （2）n行的和   2^(n - 1)
>
> 输入5，打印上述的集合`List<List<Integer>>`

java代码：

```java
public class YangHuiTriangle {
    //输出杨辉三角的集合
    //输入3   结果：[ [1],[1,1],[1,2,1] ]
    public static List<List<Integer>> generateTriangle(int numRows) {
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 1; i <= numRows; i++) {
            List<Integer> rowList = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                if (j == 0 || j == i - 1) {
                    rowList.add(1);
                } else {
                    int leftUp = result.get(i - 2).get(j - 1);
                    int up = result.get(i - 2).get(j);
                    rowList.add(leftUp + up);
                }
            }
            result.add(rowList);
        }
        return result;
    }
}
```







#### 4、java实用工具类

##### （1）二维码

谷歌：`com.google.zxing`

二维码：本质是二进制形式存储一个字符串

扫码：本质是拍张图片存进缓存，然后解析出字符串，如果是网址自动跳转，字符串自动展示



生成二维码：

```java
public class QRCode {
    public static void createQRCodeImage (String content,String fileName,int width,int height){
        QRCodeWriter writer = new QRCodeWriter();
        //encode方法参数：字符串、二维码类型、宽高
        //记录像素的位图矩阵
        BitMatrix bitMatrix = writer.encode(content,BarcodeFormat.QR_CODE,width,height);
        //获取文件系统的路径，项目根路径
        Path path = FileSystems.getDefault().getPath(fileName);
        //讲位图转化为image图像，写到路径下
        MatrixToImageWriter.writeToPath(bitMatrix,"JPG",path);
        //将位图写到流里面
        MatrixToImageWriter.writeToStream(bitMatrix,"JPG",new FileOutputStream(fileName));
    }
}
```

解析二维码：

```java
//将一个大图里的二维码进行识别
public static void parseQRCodeToString (String filePath) {
    File file = new File(filePath);
    //将文件直接读成图片image格式
    BufferedImage image = ImageIO.read(file); 
    //将image格式的文件变为图片
    //混杂二进制
    Binarizer binarizer = new BufferedImageLuminanceSource(image);
    //将混杂二进制转化为位图
    BinaryBitMap bitMap = new BinaryBitMap(binarizer);
    //解析二维码位图
    MultiFormatReader reader = new MultiFormatReader();
    //用来存放结果的对象Result
    Result result = reader.decode(bitMap);
    return result.getText();
}
```

生成条形码：

```java
public class QRCode {
    public static void createBarCode (String content,String fileName,int width,int height){
        MultiFormatWriter writer = new MultiFormatWriter();
        //encode方法参数：字符串、二维码类型、宽高
        //记录像素的位图矩阵
        BitMatrix bitMatrix = writer.encode(content,BarcodeFormat.EAN_13,width,height);
        //获取文件系统的路径，项目根路径
        Path path = FileSystem.getDefault().getPath(fileName);
        //讲位图转化为image图像，写到路径下
        MatrixToImageWriter.writeToPath(bitMatrix,"JPG",path);
        //将位图写到流里面
        MatrixToImageWriter.writeToStream(bitMatrix,"JPG",new FileOutputStream(fileName));
    }
}
```

